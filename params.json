{"name":"Treehuggerdocs","tagline":"The documentation website source for tree-hugger","body":"# Welcome to tree-hugger\r\n\r\nA light-weight, high level, universal code parser built on top of tree-sitter\r\n\r\n\r\n# Browse the documentation\r\n\r\n## Installation and setup\r\n\r\n### From pip:\r\n\r\nJust do\r\n```\r\npip install tree-hugger\r\n```\r\n\r\n### From Source:\r\n\r\n```\r\ngit clone https://github.com/autosoft-dev/tree-hugger.git\r\n\r\ncd tree-hugger\r\n\r\npip install -e .\r\n```\r\n\r\n_The installation process is tested in macOS Mojave, we have a [separate docker binding](https://github.com/autosoft-dev/tree-sitter-docker) for compiling the libraries for Linux and soon this library will be integrated in that as well_\r\n\r\n_You may need to install libgit2. In case you are in mac just use `brew install libgit2`_\r\n\r\n### Building the .so files\r\n\r\n_Please note that building the libraries has been tested under a macOS Mojave with Apple LLVM version 10.0.1 (clang-1001.0.46.4)_\r\n\r\n_Please check out our Linux specific instructions [here](https://github.com/autosoft-dev/tree-sitter-docker)_\r\n\r\nOnce this library is installed it gives you a command line utility to download and compile tree-sitter .so files with ease. As an example - \r\n\r\n```\r\ncreate_libs python\r\n```\r\n\r\nHere is the full usage guide of the command\r\n\r\n```\r\nusage: create_libs [-h] [-c] [-l LIB_NAME] langs [langs ...]\r\n\r\npositional arguments:\r\n  langs                 Give the name of languages for tree-sitter (php,\r\n                        python, go ...)\r\n\r\noptional arguments:\r\n  -h, --help            show this help message and exit\r\n  -c, --copy-to-workspace\r\n                        Shall we copy the created libs to the present dir?\r\n                        (default: False)\r\n  -l LIB_NAME, --lib-name LIB_NAME\r\n                        The name of the generated .so file\r\n```\r\n\r\n\r\n## Supported languages\r\n\r\nAt the moment, Tree-Hugger supports the following languages:\r\n- Python\r\n- PHP\r\n\r\nBecause Tree-Hugger is easily expandable, the users can extends the functionality with a custom parser or implement a new one for another language\r\n\r\n## Tutorials\r\n\r\n### A Quick Example\r\n\r\nFirst run the above command to generate the libraries.\r\n\r\nIn our settings we just use the `-c` flag to copy the generated `tree-sitter` library's `.so` file to our workspace.\r\nAnd once copied, we place it under a directory called `tslibs` (It is in the .gitignore). But of course, if you are using linux then this command probably won't work and you will need to use our [tree-sitter-docker](https://github.com/autosoft-dev/tree-sitter-docker) image and manually copy the final .so file.\r\n\r\nAnother thing that we need before we can analyze any code file is an yaml with queries. We have suuplied one example query file\r\nunder [**queries**](https://raw.githubusercontent.com/autosoft-dev/tree-hugger/master/queries/example_queries.yml) directory. \r\n\r\n*Please note that, you can set up two environment variables `QUERY_FILE_PATH` and `TS_LIB_PATH` for the query file path and \r\ntree-sitter lib path and then the libary will use them automatically. Otherwise, as an alternative, you can pass it when creating any `*Parser` object*\r\n\r\nAssuming that you have the necessary environment variable setup. The following line of code will create a `PythonParser` object\r\n\r\n```python\r\nfrom tree_hugger.core import PythonParser\r\n\r\npp = PythonParser()\r\n```\r\n\r\nAnd then you can pass in any Python file that you want to analyze, like so :\r\n\r\n```python\r\npp.parse_file(\"tests/assets/file_with_different_functions.py\")\r\nOut[3]: True\r\n```\r\n\r\n`parse_file` returns `True` if success\r\n\r\nAnd then you are free to use the methods exposed by that particular Parser object. As an example - \r\n\r\n```python\r\npp.get_all_function_names()\r\nOut[4]:\r\n['first_child',\r\n 'second_child',\r\n 'say_whee',\r\n 'wrapper',\r\n 'my_decorator',\r\n 'parent']\r\n```\r\n\r\nOR\r\n\r\n```python\r\npp.get_all_function_documentations()\r\nOut[5]:\r\n{'parent': '\"\"\"This is the parent function\\n    \\n    There are other lines in the doc string\\n    This is the third line\\n\\n    And this is the fourth\\n    \"\"\"',\r\n 'first_child': \"'''\\n        This is first child\\n        '''\",\r\n 'second_child': '\"\"\"\\n        This is second child\\n        \"\"\"',\r\n 'my_decorator': '\"\"\"\\n    Outer decorator function\\n    \"\"\"',\r\n 'say_whee': '\"\"\"\\n    Hellooooooooo\\n\\n    This is a function with decorators\\n    \"\"\"'}\r\n```\r\n\r\n## API reference\r\n\r\n### Queries: \r\nQueries are s-expressions (Remember LISP?) that works on the parsed code and gives you what you want. They are a great way to fetch arbitary data from the parsed code without having to travel through it recursively. \r\nTree-hugger gives you a way to write your queries in yaml file (Check out the `queries.yml` files in the parsers file to see some examples). \r\n\r\nThis main section  is further sub-divded into few (as many as you need, actually) sections. Each of them has the same structure. A name of a query followed by the query itself. Written as an s-expression. One example:\r\n\r\n```\r\nall_function_docstrings:\r\n        \"\r\n        (\r\n            function_definition\r\n            name: (identifier) @function.def\r\n            body: (block(expression_statement(string))) @function.docstring\r\n        )\r\n        \"\r\n```\r\nOf course, you have to follow yaml grammar while writing these queries. You can see a bit more about writng these queries in the documentation of tree-sitter. [Here](https://tree-sitter.github.io/tree-sitter/using-parsers#pattern-matching-with-queries). Although it is not very intuitive to start with. We are planning to write a detailed tutorial on this subject. \r\n\r\n### Parser Class:\r\nA parser class extends from the BaseParser class. The only mandatory argument that a Parser class should pass to the parent is the `language`. This is a string. Such as `python` (remember, lower case). Although, each parser class must\r\nhave the options to take in the path of the tree-sitter library (.so file that we are using to parse the code) and the path to the queries yaml file, in their constructor.\r\n\r\nThe BaseParser class can do few things for you. \r\n\r\n* It loads and prepares the .so file with respect to the language you just mentioned. \r\n\r\n* It loads, parses, and prepares the query yaml file. (for the queries, we internally use an extended UserDict class. More on that later.)\r\n\r\n* It gives an API to parse a file and prepare it for query. `BaseParser.parse_file`\r\n\r\n* It also gives you another (most likely not to be exposed outside) API `_run_query_and_get_captures` which lets you run any queries and return back the matched results (if any) from the parsed tree. \r\n\r\nIf you are interested to see the example of one of the methods in the PythonParser class, to know how all of these come together. Here it is (Do not forget, we use those APIs once we have called `parse_file` and parsed the file) - \r\n\r\nThe function `match_from_span` is a very handy function. It is defined in the BaseParser module. It takes a span definition and returns the underlying code string from it.\r\n","note":"Don't delete this file! It's used internally to help with page regeneration."}